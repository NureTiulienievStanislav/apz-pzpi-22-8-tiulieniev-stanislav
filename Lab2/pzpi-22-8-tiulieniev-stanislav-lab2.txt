Міністерство освіти та науки України
Харківський національний університет
радіоелектроніки


Кафедра ПІ


Звіт
З лабораторної роботи 2
з дисципліни «Архітектура програмного забезпечення»
на тему: «Розробка програмної архітектури, створення та
відлагодження програмного коду серверної частини
програмної системи»




Виконав:	Перевірив:
ст. гр. ПЗПІ-22-8	ст. викладач Сокорчук І.П.
Тюлєнєв С.О.	 



Харків 2025



Мета роботи:
Потрібно розробити серверну / back-end частину програмної системи.

Історія змін:
№	Дата	Версія	Опис змін	Автор
1	21.05.2025	0.1	Створено структуру звіту	Тюлєнєв Станіслав
2	22.05.2025	0.2	Додано діаграми та інженерні рішення	Тюлєнєв Станіслав
3	23.05.2025	1.0	Фіналізовано звіт	Тюлєнєв Станіслав

Опис виконаної роботи:
Було створено архітектуру та реалізовано всі ключові компоненти програмної системи TrackWay. Програмна система TrackWay реалізована з урахуванням багаторівневої архітектури, яка включає презентаційний рівень (веб-інтерфейс і мобільний додаток), серверну частину (REST API на Node.js), базу даних (MongoDB), а також IoT-рівень, який відповідає за збір телеметричних даних у реальному часі з використанням MQTT.
Серверна частина побудована за допомогою фреймворку Express.js. Вона організована модульно: контролери обробляють логіку, маршрути відповідають за API-взаємодію, а middleware реалізують автентифікацію і перевірку ролей. Дані зберігаються у MongoDB, доступ до яких здійснюється через ORM Mongoose. Передача даних від IoT-емулятора здійснюється через MQTT-брокер.
Для обробки користувацьких даних у системі використовується генерація псевдовипадкових значень для емуляції даних датчиків. Дистанція спереду та ззаду автомобіля моделюється з допомогою Math.random() і округлюється до двох десяткових знаків. Для захисту системи від помилкових значень передбачено фільтрацію: значення, що виходять за межі допустимого діапазону (0–10 м), ігноруються.
У серверній частині для обробки даних реалізовані прості математичні операції: перевірка на порогові значення, фільтрація, агрегація даних (наприклад, обчислення середньої дистанції для кожного авто), а також сортування за часом або за VIN.
ER-модель системи базується на трьох ключових сутностях: користувачі (users), транспортні засоби (vehicles) і маршрути (routes). Кожна з них має унікальний ідентифікатор (ObjectId) і поля, що відповідають їхній логіці. Користувач може мати кілька автомобілів, а кожен автомобіль — один або кілька маршрутів. Такі зв’язки реалізовані через посилання типу ObjectId у Mongoose-схемах.
Комунікація між компонентами програмної системи реалізована через REST API. Кожен HTTP-запит виконує певну функцію: авторизація (POST /login), реєстрація (POST /register), додавання авто (POST /vehicles), перегляд списку ТЗ (GET /vehicles), видалення авто (DELETE /vehicles/:id), додавання маршруту (POST /routes). Всі захищені запити вимагають заголовок авторизації з JWT-токеном.
У серверній частині використовуються такі технології: Node.js, Express.js, MongoDB з Mongoose, бібліотека jsonwebtoken для авторизації, bcrypt для хешування паролів, dotenv для роботи зі змінними середовища, cors для підтримки міждоменного доступу. MQTT реалізовано через бібліотеку mqtt.js для обробки телеметрії з пристроїв.
Для підтримки багатомовності реалізовано базову інтерналізацію: текстові повідомлення системи можуть зберігатись у окремих JSON-файлах мовами користувача. Під час відповіді сервер перевіряє заголовок Accept-Language і повертає повідомлення відповідною мовою.
Серверна частина реалізована в окремих модулях: app.js ініціалізує сервер, підключає маршрути, базу даних та MQTT-зʼєднання. Контролери виконують логіку обробки запитів, перевіряють права доступу, відповідають за створення, видалення, оновлення даних. Кожен маршрут захищено middleware, що перевіряє автентифікацію та роль користувача.
Функціональне тестування проводилось через Swagger UI та Postman. Тестувались: успішний та неуспішний логін, обмеження доступу за ролями, додавання і видалення ТЗ, симуляція телеметрії через MQTT. Також перевірено поведінку при відсутності токена, помилках валідації та при неправильному маршруті. Усі компоненти працюють відповідно до специфікації.
ER-діаграма системи TrackWay відображає логічну структуру бази даних, яка включає три ключові сутності: користувачів (users), транспортні засоби (vehicles) та маршрути (routes). Кожен користувач має унікальний ідентифікатор, ім’я користувача, пароль та роль (admin або driver). Кожен транспортний засіб містить інформацію про марку, модель, рік випуску, VIN-код, а також два поля для IoT-даних — дистанція спереду і ззаду. Кожен маршрут містить початкову та кінцеву позиції і посилання на відповідний транспортний засіб. 
UML-діаграма прецедентів показує взаємодію користувачів з функціональністю системи. В системі присутні два актори: диспетчер (admin) і водій (driver). Адміністратор має доступ до всіх можливостей: реєстрація, авторизація, додавання та видалення транспортних засобів, перегляд усього автопарку, призначення маршрутів. Водій має доступ до реєстрації, авторизації та перегляду призначених транспортних засобів. 
Діаграма розгортання демонструє архітектуру розміщення компонентів у фізичному середовищі. Веб-клієнт, реалізований на React, та мобільний додаток на Kotlin комунікують з backend-сервером, побудованим на Node.js. Сервер взаємодіє з базою даних MongoDB і приймає телеметричні дані від IoT-пристроїв через MQTT-брокер. 
Діаграма діяльності описує логіку виконання операції додавання нового транспортного засобу. Користувач заповнює форму з даними, після чого відбувається перевірка авторизації. У разі підтвердження прав система надсилає запит до сервера. Якщо все успішно, виконується оновлення списку транспортних засобів у клієнті. У разі відсутності авторизації або помилок запиту система повертає відповідне повідомлення. 
Серверні компоненти:
- UserController: реєстрація, логін, видалення
- VehicleController: додавання, перегляд, видалення ТЗ
- RouteController: створення маршрутів
- AuthMiddleware: перевірка токена та ролей
- MqttService: прийом IoT-даних у реальному часі
Frontend реалізовано як SPA на React, з авторизацією, формою додавання ТЗ та відображенням IoT-даних. Мобільний додаток на Kotlin дозволяє водіям бачити свої авто, маршрути та сповіщення.

Висновки:
У результаті виконання лабораторної роботи було реалізовано повноцінну систему TrackWay з клієнтською, серверною та IoT-інфраструктурою. Система протестована, підтримує облік ТЗ, маршрути, телеметрію та рольовий доступ. TrackWay демонструє реальну інтеграцію IoT з веб і мобільними технологіями для автоматизації керування автопарком.
 
ДОДАТОК А
Посилання на відеозапис доповіді

Відеозапис доповіді на YouTube: https://youtu.be/prwsijsgE2A
Нижче наведено хронологічний опис доповіді.
00:00 – Вітання.
0:20 – Функція реєстрації користувача.
0:35 – Функція авторизації користувача.
01:07 – Функція видалення користувача.
01:20 – Функція показу автомобілів. 
01:30 – Функція видалення автомобілів. 
01:42 – Функції додавання автомобілів.
01:43 – Завершення.




ДОДАТОК Б

 
Рисунок Б.1 — ER-діаграма даних
 
Рисунок Б.2 — Структура бази даних
 
Рисунок Б.3 — UML-діаграма прецедентів
 
Рисунок Б.4 — діаграма розгортання
 
Рисунок Б.5 — діаграма діяльності




ДОДАТОК В
Програмий код

В.1 Обробка та агрегація телеметричних даних
1 function calculateAverages(dataList) {
 2   let totalFront = 0
 3   let totalRear = 0
 4   let count = 0
 5
 6   for (const item of dataList) {
 7     const front = parseFloat(item.front_iot)
 8     const rear = parseFloat(item.back_iot)
 9
10     if (!isNaN(front) && front >= 0 && front <= 10 &&
11         !isNaN(rear) && rear >= 0 && rear <= 10) {
12       totalFront += front
13       totalRear += rear
14       count++
15     }
16   }
17
18   return {
19     avgFront: count ? (totalFront / count).toFixed(2) : 'N/A',
20     avgRear: count ? (totalRear / count).toFixed(2) : 'N/A',
21     totalPoints: count
22   }
23 }


В.2 Додавання транспортного засобу з перевіркою VIN
1 exports.createVehicle = async (req, res) => {
 2   try {
 3     const { make, model, year, vin } = req.body
 4
 5     if (!make || !model || !year || !vin) {
 6       return res.status(400).json({ message: 'Не всі поля заповнено' })
 7     }
 8
 9     const duplicate = await Vehicle.findOne({ vin })
10     if (duplicate) {
11       return res.status(409).json({ message: 'Такий VIN вже існує' })
12     }
13
14     const vehicle = new Vehicle({
15       make,
16       model,
17       year,
18       vin,
19       front_iot: (Math.random() * 10).toFixed(2),
20       back_iot: (Math.random() * 10).toFixed(2)
21     })
22
23     await vehicle.save()
24     res.status(201).json(vehicle)
25   } catch (err) {
26     res.status(500).json({ message: 'Помилка на сервері' })
27   }
28 }



В.3 Отримання та збереження IoT-даних через MQTT
1 const mqtt = require('mqtt')
 2 const Vehicle = require('../models/Vehicle')
 3
 4 const client = mqtt.connect('mqtt://localhost:1883')
 5
 6 client.on('connect', () => {
 7   client.subscribe('trackway/telemetry')
 8 })
 9
10 client.on('message', async (topic, message) => {
11   try {
12     const { vin, front, rear } = JSON.parse(message.toString())
13
14     if (!vin || isNaN(front) || isNaN(rear)) return
15
16     await Vehicle.findOneAndUpdate(
17       { vin },
18       { front_iot: front.toFixed(2), back_iot: rear.toFixed(2) }
19     )
20
21     console.log(`Оновлено: ${vin}`)
22   } catch (error) {
23     console.error('MQTT помилка:', error.message)
24   }
25 })

